% Проблемы:
% генератор давал не дискретный сигнал
% подбор параметров (так как нигде не описан)
% долго был ноль на выходе в итоге, частота дискретизации "To workspace"

clear all;
Ts = 0.001; % Интервал дискретизации (шаг)
Ns = 10000; % Количество отсчетов

% Фиксированные параметры
Am = 100;
mr = 10;

% Диапазоны факторов NP (a) и R (b)
nf = 2;
minf = [0.025, 2];
maxf = [0.1, 5];

% Формируем дробный факторный план эксперимента
fracplan = fracfact('a b ab')
N = 2 ^ nf; % Определяем количество экспериментов
fictfact = ones(N, 1); % генерируем фиктивный фактор
X = [fictfact fracplan]'; % добавляем фиктивный фактор

% Преобразование кодированных значений в реальные
fraceks = zeros(N, nf);
for i = 1:nf
    for j = 1:N
        fraceks(j, i) = minf(i) + (fracplan(j, i) + 1) * (maxf(i) - minf(i)) / 2;
    end
end

fraceks

% Доверительный интервал и уровень значимости
dm = 0.03; % Допустимая ошибка (чем она меньше, тем больше нужно испытаний)
alpha = 0.05; % 95% доверительный интервал
tkr_alpha = norminv(1 - alpha / 2); % расчет t критичекого для
% расчета кол-ва испытаний

% Массив для хранения СКО
Y = zeros(N, 1);

% Цикл по экспериментам
for j = 1:N
    NP = fraceks(j, 1); % получаем значение NP в данном эксперименте
    R = fraceks(j, 2); % получаем значение R в данном эксперименте
    
    NE = 1; % Начальное количество испытаний
    l = 0; % переменная-счетчик для суммы наблюдений
    SQ = 0; % переменная-счетчик для суммы квадратов наблюдений
    D = 1; % Начальная дисперсия

    uo = []; % Входной сигнал
    u1 = []; % Демодулированный сигнал

    % формула числа испытаний из лекции:
    while NE < tkr_alpha^2 * D / dm^2
        to = round(rand * 100); % Инициализация генератора шума

        sim('trenl', Ts * Ns); % запуск (Ts * Ns) прогонов симуляции

        % получение суммы значений сигналов на выходе генератора:
        uo(end+1) = sum(simout); 
        % получение суммы значений сигналов на выходе демодулятора:
        u1(end+1) = sum(simout1);

        % степень превышения порога обнаружения полезного сигнала 
        % над уровнем входного шума (отображение для отладки):
        disp(mr * sqrt(NP)) 

        % Обновление статистики
        l = l + u1(end); % прибавляем очередное наблюдение
        SQ = SQ + u1(end)^2; % прибавляем квадрат очередного наблюдения

        if NE > 1 % >1, чтобы не было деления на 0
            D = SQ / (NE - 1) - (l^2) / (NE * (NE - 1)); % Выборочная дисперсия
        end

        NE = NE + 1; % увеличиваем порядковый номер испытания
    end

    NE = NE - 1; % Исправляем на реальное число испытаний
    % так как в предыдущем цикле был лишний инкремент

    % Расчет СКО между исходным (uo) и демодулированным (u1) сигналами
    SKO = sqrt(mean((uo - u1).^2));
    Y(j) = SKO; % Запись результата
end

% Расчет коэффициентов регрессии
C = X * X';
b_ = inv(C) * X * Y;

% Формируем поверхность реакции
A = minf(1):0.01:maxf(1);
B = minf(2):0.1:maxf(2);
[k, N1] = size(A);
[k, N2] = size(B);

% Расчет коэффициентов поверхности через коэффициенты регрессии:
for i = 1:N1
    for j = 1:N2
        an(i) = 2 * (A(i) - minf(1)) / (maxf(1) - minf(1)) - 1;
        bn(j) = 2 * (B(j) - minf(2)) / (maxf(2) - minf(2)) - 1;
        Yc(j, i) = b_(1) + an(i) * b_(2) + bn(j) * b_(3) + an(i) * bn(j) * b_(4);
    end
end

% Построение графика
[x, y] = meshgrid(A, B);
figure;
subplot(1,1,1), mesh(x, y, Yc);
xlabel('NP (Мощность шума)');
ylabel('R (Расстояние)');
zlabel('СКО');
title('Зависимость СКО от мощности шума и расстояния');

grid on;
